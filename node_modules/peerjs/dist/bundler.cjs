var $duLG9$peerjsjsbinarypack = require("peerjs-js-binarypack");
var $duLG9$webrtcadapter = require("webrtc-adapter");
var $duLG9$eventemitter3 = require("eventemitter3");

function $parcel$defineInteropFlag(a) {
  Object.defineProperty(a, '__esModule', {value: true, configurable: true});
}
function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$defineInteropFlag(module.exports);

$parcel$export(module.exports, "default", () => $8dc2c2301642b6f0$export$2e2bcd8739ae039);
$parcel$export(module.exports, "Peer", () => $bdba2c07c560828e$export$ecd1fc136c422448);
$parcel$export(module.exports, "util", () => $8677acc278daa2d1$export$7debb50ef11d5e0b);


const $c29002be8a39421f$export$25be9502477c137d = new class {
    isIOS = [
        "iPad",
        "iPhone",
        "iPod"
    ].includes(navigator.platform);
    supportedBrowsers = [
        "firefox",
        "chrome",
        "safari"
    ];
    minFirefoxVersion = 59;
    minChromeVersion = 72;
    minSafariVersion = 605;
    isWebRTCSupported() {
        return typeof RTCPeerConnection !== "undefined";
    }
    isBrowserSupported() {
        const browser = this.getBrowser();
        const version = this.getVersion();
        const validBrowser = this.supportedBrowsers.includes(browser);
        if (!validBrowser) return false;
        if (browser === "chrome") return version >= this.minChromeVersion;
        if (browser === "firefox") return version >= this.minFirefoxVersion;
        if (browser === "safari") return !this.isIOS && version >= this.minSafariVersion;
        return false;
    }
    getBrowser() {
        return ($parcel$interopDefault($duLG9$webrtcadapter)).browserDetails.browser;
    }
    getVersion() {
        return ($parcel$interopDefault($duLG9$webrtcadapter)).browserDetails.version || 0;
    }
    isUnifiedPlanSupported() {
        const browser = this.getBrowser();
        const version = ($parcel$interopDefault($duLG9$webrtcadapter)).browserDetails.version || 0;
        if (browser === "chrome" && version < this.minChromeVersion) return false;
        if (browser === "firefox" && version >= this.minFirefoxVersion) return true;
        if (!window.RTCRtpTransceiver || !("currentDirection" in RTCRtpTransceiver.prototype)) return false;
        let tempPc;
        let supported = false;
        try {
            tempPc = new RTCPeerConnection();
            tempPc.addTransceiver("audio");
            supported = true;
        } catch (e) {} finally{
            if (tempPc) tempPc.close();
        }
        return supported;
    }
    toString() {
        return `Supports: 
    browser:${this.getBrowser()} 
    version:${this.getVersion()} 
    isIOS:${this.isIOS} 
    isWebRTCSupported:${this.isWebRTCSupported()} 
    isBrowserSupported:${this.isBrowserSupported()} 
    isUnifiedPlanSupported:${this.isUnifiedPlanSupported()}`;
    }
}();


const $8677acc278daa2d1$var$DEFAULT_CONFIG = {
    iceServers: [
        {
            urls: "stun:stun.l.google.com:19302"
        },
        {
            urls: [
                "turn:eu-0.turn.peerjs.com:3478",
                "turn:eu-1.turn.peerjs.com:3478", 
            ],
            username: "peerjs",
            credential: "peerjsp"
        },
        {
            urls: [
                "turn:us-0.turn.peerjs.com:3478",
                "turn:us-1.turn.peerjs.com:3478", 
            ],
            username: "peerjs",
            credential: "peerjsp"
        }, 
    ],
    sdpSemantics: "unified-plan"
};
class $8677acc278daa2d1$var$Util {
    noop() {}
    CLOUD_HOST = "0.peerjs.com";
    CLOUD_PORT = 443;
    // Browsers that need chunking:
    chunkedBrowsers = {
        Chrome: 1,
        chrome: 1
    };
    chunkedMTU = 16300;
    // Returns browser-agnostic default config
    defaultConfig = $8677acc278daa2d1$var$DEFAULT_CONFIG;
    browser = $c29002be8a39421f$export$25be9502477c137d.getBrowser();
    browserVersion = $c29002be8a39421f$export$25be9502477c137d.getVersion();
    // Lists which features are supported
    supports = (function() {
        const supported = {
            browser: $c29002be8a39421f$export$25be9502477c137d.isBrowserSupported(),
            webRTC: $c29002be8a39421f$export$25be9502477c137d.isWebRTCSupported(),
            audioVideo: false,
            data: false,
            binaryBlob: false,
            reliable: false
        };
        if (!supported.webRTC) return supported;
        let pc;
        try {
            pc = new RTCPeerConnection($8677acc278daa2d1$var$DEFAULT_CONFIG);
            supported.audioVideo = true;
            let dc;
            try {
                dc = pc.createDataChannel("_PEERJSTEST", {
                    ordered: true
                });
                supported.data = true;
                supported.reliable = !!dc.ordered;
                // Binary test
                try {
                    dc.binaryType = "blob";
                    supported.binaryBlob = !$c29002be8a39421f$export$25be9502477c137d.isIOS;
                } catch (e) {}
            } catch (e) {} finally{
                if (dc) dc.close();
            }
        } catch (e) {} finally{
            if (pc) pc.close();
        }
        return supported;
    })();
    // Ensure alphanumeric ids
    validateId(id) {
        // Allow empty ids
        return !id || /^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.test(id);
    }
    pack = $duLG9$peerjsjsbinarypack.pack;
    unpack = $duLG9$peerjsjsbinarypack.unpack;
    // Binary stuff
    _dataCount = 1;
    chunk(blob) {
        const chunks = [];
        const size = blob.size;
        const total = Math.ceil(size / $8677acc278daa2d1$export$7debb50ef11d5e0b.chunkedMTU);
        let index = 0;
        let start = 0;
        while(start < size){
            const end = Math.min(size, start + $8677acc278daa2d1$export$7debb50ef11d5e0b.chunkedMTU);
            const b = blob.slice(start, end);
            const chunk = {
                __peerData: this._dataCount,
                n: index,
                data: b,
                total: total
            };
            chunks.push(chunk);
            start = end;
            index++;
        }
        this._dataCount++;
        return chunks;
    }
    blobToArrayBuffer(blob, cb) {
        const fr = new FileReader();
        fr.onload = function(evt) {
            if (evt.target) cb(evt.target.result);
        };
        fr.readAsArrayBuffer(blob);
        return fr;
    }
    binaryStringToArrayBuffer(binary) {
        const byteArray = new Uint8Array(binary.length);
        for(let i = 0; i < binary.length; i++)byteArray[i] = binary.charCodeAt(i) & 0xff;
        return byteArray.buffer;
    }
    randomToken() {
        return Math.random().toString(36).slice(2);
    }
    isSecure() {
        return location.protocol === "https:";
    }
}
const $8677acc278daa2d1$export$7debb50ef11d5e0b = new $8677acc278daa2d1$var$Util();




const $81658c5d91b2b83a$var$LOG_PREFIX = "PeerJS: ";
let $81658c5d91b2b83a$export$243e62d78d3b544d;
(function($81658c5d91b2b83a$export$243e62d78d3b544d) {
    $81658c5d91b2b83a$export$243e62d78d3b544d[$81658c5d91b2b83a$export$243e62d78d3b544d["Disabled"] = 0] = "Disabled";
    $81658c5d91b2b83a$export$243e62d78d3b544d[$81658c5d91b2b83a$export$243e62d78d3b544d["Errors"] = 1] = "Errors";
    $81658c5d91b2b83a$export$243e62d78d3b544d[$81658c5d91b2b83a$export$243e62d78d3b544d["Warnings"] = 2] = "Warnings";
    $81658c5d91b2b83a$export$243e62d78d3b544d[$81658c5d91b2b83a$export$243e62d78d3b544d["All"] = 3] = "All";
})($81658c5d91b2b83a$export$243e62d78d3b544d || ($81658c5d91b2b83a$export$243e62d78d3b544d = {}));
class $81658c5d91b2b83a$var$Logger {
    _logLevel = $81658c5d91b2b83a$export$243e62d78d3b544d.Disabled;
    get logLevel() {
        return this._logLevel;
    }
    set logLevel(logLevel) {
        this._logLevel = logLevel;
    }
    log(...args) {
        if (this._logLevel >= $81658c5d91b2b83a$export$243e62d78d3b544d.All) this._print($81658c5d91b2b83a$export$243e62d78d3b544d.All, ...args);
    }
    warn(...args) {
        if (this._logLevel >= $81658c5d91b2b83a$export$243e62d78d3b544d.Warnings) this._print($81658c5d91b2b83a$export$243e62d78d3b544d.Warnings, ...args);
    }
    error(...args) {
        if (this._logLevel >= $81658c5d91b2b83a$export$243e62d78d3b544d.Errors) this._print($81658c5d91b2b83a$export$243e62d78d3b544d.Errors, ...args);
    }
    setLogFunction(fn) {
        this._print = fn;
    }
    _print(logLevel, ...rest) {
        const copy = [
            $81658c5d91b2b83a$var$LOG_PREFIX,
            ...rest
        ];
        for(let i in copy)if (copy[i] instanceof Error) copy[i] = "(" + copy[i].name + ") " + copy[i].message;
        if (logLevel >= $81658c5d91b2b83a$export$243e62d78d3b544d.All) console.log(...copy);
        else if (logLevel >= $81658c5d91b2b83a$export$243e62d78d3b544d.Warnings) console.warn("WARNING", ...copy);
        else if (logLevel >= $81658c5d91b2b83a$export$243e62d78d3b544d.Errors) console.error("ERROR", ...copy);
    }
}
var $81658c5d91b2b83a$export$2e2bcd8739ae039 = new $81658c5d91b2b83a$var$Logger();




let $09f19ceb374f83a1$export$4aa6b1b0bfb253ab;
(function($09f19ceb374f83a1$export$4aa6b1b0bfb253ab) {
    $09f19ceb374f83a1$export$4aa6b1b0bfb253ab["Open"] = "open";
    $09f19ceb374f83a1$export$4aa6b1b0bfb253ab["Stream"] = "stream";
    $09f19ceb374f83a1$export$4aa6b1b0bfb253ab["Data"] = "data";
    $09f19ceb374f83a1$export$4aa6b1b0bfb253ab["Close"] = "close";
    $09f19ceb374f83a1$export$4aa6b1b0bfb253ab["Error"] = "error";
    $09f19ceb374f83a1$export$4aa6b1b0bfb253ab["IceStateChanged"] = "iceStateChanged";
})($09f19ceb374f83a1$export$4aa6b1b0bfb253ab || ($09f19ceb374f83a1$export$4aa6b1b0bfb253ab = {}));
let $09f19ceb374f83a1$export$3157d57b4135e3bc;
(function($09f19ceb374f83a1$export$3157d57b4135e3bc) {
    $09f19ceb374f83a1$export$3157d57b4135e3bc["Data"] = "data";
    $09f19ceb374f83a1$export$3157d57b4135e3bc["Media"] = "media";
})($09f19ceb374f83a1$export$3157d57b4135e3bc || ($09f19ceb374f83a1$export$3157d57b4135e3bc = {}));
let $09f19ceb374f83a1$export$968b5e1359134530;
(function($09f19ceb374f83a1$export$968b5e1359134530) {
    $09f19ceb374f83a1$export$968b5e1359134530["Open"] = "open";
    $09f19ceb374f83a1$export$968b5e1359134530["Close"] = "close";
    $09f19ceb374f83a1$export$968b5e1359134530["Connection"] = "connection";
    $09f19ceb374f83a1$export$968b5e1359134530["Call"] = "call";
    $09f19ceb374f83a1$export$968b5e1359134530["Disconnected"] = "disconnected";
    $09f19ceb374f83a1$export$968b5e1359134530["Error"] = "error";
})($09f19ceb374f83a1$export$968b5e1359134530 || ($09f19ceb374f83a1$export$968b5e1359134530 = {}));
let $09f19ceb374f83a1$export$9547aaa2e39030ff;
(function($09f19ceb374f83a1$export$9547aaa2e39030ff) {
    $09f19ceb374f83a1$export$9547aaa2e39030ff["BrowserIncompatible"] = "browser-incompatible";
    $09f19ceb374f83a1$export$9547aaa2e39030ff["Disconnected"] = "disconnected";
    $09f19ceb374f83a1$export$9547aaa2e39030ff["InvalidID"] = "invalid-id";
    $09f19ceb374f83a1$export$9547aaa2e39030ff["InvalidKey"] = "invalid-key";
    $09f19ceb374f83a1$export$9547aaa2e39030ff["Network"] = "network";
    $09f19ceb374f83a1$export$9547aaa2e39030ff["PeerUnavailable"] = "peer-unavailable";
    $09f19ceb374f83a1$export$9547aaa2e39030ff["SslUnavailable"] = "ssl-unavailable";
    $09f19ceb374f83a1$export$9547aaa2e39030ff["ServerError"] = "server-error";
    $09f19ceb374f83a1$export$9547aaa2e39030ff["SocketError"] = "socket-error";
    $09f19ceb374f83a1$export$9547aaa2e39030ff["SocketClosed"] = "socket-closed";
    $09f19ceb374f83a1$export$9547aaa2e39030ff["UnavailableID"] = "unavailable-id";
    $09f19ceb374f83a1$export$9547aaa2e39030ff["WebRTC"] = "webrtc";
})($09f19ceb374f83a1$export$9547aaa2e39030ff || ($09f19ceb374f83a1$export$9547aaa2e39030ff = {}));
let $09f19ceb374f83a1$export$89f507cf986a947;
(function($09f19ceb374f83a1$export$89f507cf986a947) {
    $09f19ceb374f83a1$export$89f507cf986a947["Binary"] = "binary";
    $09f19ceb374f83a1$export$89f507cf986a947["BinaryUTF8"] = "binary-utf8";
    $09f19ceb374f83a1$export$89f507cf986a947["JSON"] = "json";
})($09f19ceb374f83a1$export$89f507cf986a947 || ($09f19ceb374f83a1$export$89f507cf986a947 = {}));
let $09f19ceb374f83a1$export$3b5c4a4b6354f023;
(function($09f19ceb374f83a1$export$3b5c4a4b6354f023) {
    $09f19ceb374f83a1$export$3b5c4a4b6354f023["Message"] = "message";
    $09f19ceb374f83a1$export$3b5c4a4b6354f023["Disconnected"] = "disconnected";
    $09f19ceb374f83a1$export$3b5c4a4b6354f023["Error"] = "error";
    $09f19ceb374f83a1$export$3b5c4a4b6354f023["Close"] = "close";
})($09f19ceb374f83a1$export$3b5c4a4b6354f023 || ($09f19ceb374f83a1$export$3b5c4a4b6354f023 = {}));
let $09f19ceb374f83a1$export$adb4a1754da6f10d;
(function($09f19ceb374f83a1$export$adb4a1754da6f10d) {
    $09f19ceb374f83a1$export$adb4a1754da6f10d["Heartbeat"] = "HEARTBEAT";
    $09f19ceb374f83a1$export$adb4a1754da6f10d["Candidate"] = "CANDIDATE";
    $09f19ceb374f83a1$export$adb4a1754da6f10d["Offer"] = "OFFER";
    $09f19ceb374f83a1$export$adb4a1754da6f10d["Answer"] = "ANSWER";
    $09f19ceb374f83a1$export$adb4a1754da6f10d["Open"] = "OPEN";
    $09f19ceb374f83a1$export$adb4a1754da6f10d["Error"] = "ERROR";
    $09f19ceb374f83a1$export$adb4a1754da6f10d["IdTaken"] = "ID-TAKEN";
    $09f19ceb374f83a1$export$adb4a1754da6f10d["InvalidKey"] = "INVALID-KEY";
    $09f19ceb374f83a1$export$adb4a1754da6f10d["Leave"] = "LEAVE";
    $09f19ceb374f83a1$export$adb4a1754da6f10d["Expire"] = "EXPIRE";
})($09f19ceb374f83a1$export$adb4a1754da6f10d || ($09f19ceb374f83a1$export$adb4a1754da6f10d = {}));


var $1572597be94ce13f$exports = {};
$1572597be94ce13f$exports = JSON.parse("{\"name\":\"peerjs\",\"version\":\"1.4.0\",\"keywords\":[\"peerjs\",\"webrtc\",\"p2p\",\"rtc\"],\"description\":\"PeerJS client\",\"homepage\":\"https://peerjs.com\",\"bugs\":{\"url\":\"https://github.com/peers/peerjs/issues\"},\"repository\":{\"type\":\"git\",\"url\":\"https://github.com/peers/peerjs\"},\"license\":\"MIT\",\"contributors\":[\"Michelle Bu <michelle@michellebu.com>\",\"afrokick <devbyru@gmail.com>\",\"ericz <really.ez@gmail.com>\",\"Jairo <kidandcat@gmail.com>\",\"Jairo Caro-Accino Viciana <jairo@galax.be>\",\"Carlos Caballero <carlos.caballero.gonzalez@gmail.com>\",\"hc <hheennrryy@gmail.com>\",\"Muhammad Asif <capripio@gmail.com>\",\"PrashoonB <prashoonbhattacharjee@gmail.com>\",\"Moritz Stückler <moritz.stueckler@gmail.com>\",\"Harsh Bardhan Mishra <47351025+HarshCasper@users.noreply.github.com>\",\"akotynski <aleksanderkotbury@gmail.com>\",\"Jairooo <jairocaro@msn.com>\",\"lmb <i@lmb.io>\",\"Jonas Gloning <34194370+jonasgloning@users.noreply.github.com>\",\"Simon <crydotsnakegithub@gmail.com>\",\"Philipp Hancke <fippo@andyet.net>\",\"Matthias Lohr <matthias@lohr.me>\",\"Jess <jessachandler@gmail.com>\",\"khankuan <khankuan@gmail.com>\",\"Denis Lukov <denismassters@gmail.com>\",\"Hans Oksendahl <hansoksendahl@gmail.com>\",\"XiZhao <kwang1imsa@gmail.com>\",\"DUODVK <kurmanov.work@gmail.com>\",\"Sören Balko <Soeren.Balko@gmail.com>\",\"Steve Blaurock <sblaurock@gmail.com>\",\"Yemel Jardi <angel.jardi@gmail.com>\",\"Yuki Ito <yuki@gnnk.net>\",\"alxnull <alxnull@e.mail.de>\",\"bob.barstead@exaptive.com <bob.barstead@exaptive.com>\",\"chandika <chandika@gmail.com>\",\"eddieherm <edhermoso@gmail.com>\",\"emersion <contact@emersion.fr>\",\"fresheneesz <bitetrudpublic@gmail.com>\",\"jasonbarry <jasbarry@me.com>\",\"jonnyf <github@jonathanfoss.co.uk>\",\"=frank tree <=frnktrb@googlemail.com>\",\"xizhao <kevin.wang@cloudera.com>\",\"Alberto Torres <kungfoobar@gmail.com>\",\"Alex Chuev <alex@chuev.com>\",\"Andre Eckardt <aeckardt@outlook.com>\",\"Arpit Solanki <solankiarpit1997@gmail.com>\",\"Artur Zayats <zag2art@gmail.com>\",\"Ben Parnell <benjaminparnell.94@gmail.com>\",\"Benny Lichtner <bennlich@gmail.com>\",\"Chris Cowan <agentme49@gmail.com>\",\"Christopher Van <cvan@users.noreply.github.com>\",\"Diwank Singh Tomer <singh@diwank.name>\",\"Eduardo Pinho <enet4mikeenet@gmail.com>\",\"Evandro Zanatta <ezanatta@tray.net.br>\",\"Gardner Bickford <gardner@users.noreply.github.com>\",\"Gian Luca <gianluca.cecchi@cynny.com>\",\"Hizkia Felix <hizkifw@gmail.com>\",\"Hristo Oskov <hristo.oskov@gmail.com>\",\"Ilya Konanykhin <ilya.konanykhin@gmail.com>\",\"Isaac Madwed <i.madwed@gmail.com>\",\"Jefferson Felix <me@jsfelix.dev>\",\"Jonathan Burke <jonathan.burke.1311@googlemail.com>\",\"Jonathan Mayol <mayoljonathan@gmail.com>\",\"JooYoung <qkdlql@naver.com>\",\"Jordan Austin <jrax86@gmail.com>\",\"Josh Hamit <josh.hamit@gmail.com>\",\"Kevin Mai-Husan Chia <mhchia@users.noreply.github.com>\",\"Kyrylo Shegeda <shegeda@ualberta.ca>\",\"PatrickJS <github@gdi2290.com>\",\"Pepijn de Vos <pepijndevos@gmail.com>\",\"Rolf Erik Lekang <me@rolflekang.com>\"],\"funding\":{\"type\":\"opencollective\",\"url\":\"https://opencollective.com/peer\"},\"collective\":{\"type\":\"opencollective\",\"url\":\"https://opencollective.com/peer\"},\"files\":[\"dist/*\"],\"type\":\"module\",\"sideEffects\":[\"lib/global.ts\",\"lib/supports.ts\"],\"main\":\"dist/bundler.cjs\",\"browser-minified\":\"dist/peerjs.min.cjs\",\"browser-unminified\":\"dist/peerjs.cjs\",\"types\":\"dist/types.d.ts\",\"targets\":{\"types\":{\"source\":\"lib/exports.ts\"},\"main\":{\"source\":\"lib/exports.ts\"},\"browser-minified\":{\"includeNodeModules\":true,\"context\":\"browser\",\"optimize\":true,\"engines\":{\"browsers\":\"cover 99%, not dead\"},\"source\":\"lib/global.ts\"},\"browser-unminified\":{\"includeNodeModules\":true,\"context\":\"browser\",\"optimize\":false,\"engines\":{\"browsers\":\"cover 99%, not dead\"},\"source\":\"lib/global.ts\"}},\"scripts\":{\"check\":\"tsc --noEmit\",\"watch\":\"parcel watch\",\"build\":\"rm -rf dist && parcel build && ln -s dist/peerjs.cjs dist/peerjs.js && ln -s dist/peerjs.min.cjs dist/peerjs.min.js\",\"prepublishOnly\":\"npm run build\",\"test\":\"mocha -r ts-node/register -r jsdom-global/register test/**/*.ts\",\"format\":\"prettier --write .\",\"semantic-release\":\"semantic-release\"},\"devDependencies\":{\"@parcel/packager-ts\":\"^2.5.0\",\"@parcel/transformer-typescript-types\":\"^2.5.0\",\"@semantic-release/changelog\":\"^6.0.1\",\"@semantic-release/git\":\"^10.0.1\",\"@types/chai\":\"^4.3.0\",\"@types/mocha\":\"^9.1.0\",\"@types/node\":\"^17.0.18\",\"chai\":\"^4.3.6\",\"jsdom\":\"^19.0.0\",\"jsdom-global\":\"^3.0.2\",\"mocha\":\"^9.2.0\",\"mock-socket\":\"8.0.5\",\"parcel\":\"^2.5.0\",\"prettier\":\"^2.6.2\",\"semantic-release\":\"^19.0.2\",\"standard\":\"^16.0.4\",\"ts-node\":\"^10.5.0\",\"typescript\":\"^4.5.5\"},\"dependencies\":{\"eventemitter3\":\"^3.1.2\",\"peerjs-js-binarypack\":\"1.0.1\",\"webrtc-adapter\":\"^7.7.1\"}}");


class $9bb55f9334914a06$export$4798917dbf149b79 extends $duLG9$eventemitter3.EventEmitter {
    constructor(secure, host, port, path, key, pingInterval = 5000){
        super();
        this.pingInterval = pingInterval;
        this._disconnected = true;
        this._messagesQueue = [];
        const wsProtocol = secure ? "wss://" : "ws://";
        this._baseUrl = wsProtocol + host + ":" + port + path + "peerjs?key=" + key;
    }
    start(id, token) {
        this._id = id;
        const wsUrl = `${this._baseUrl}&id=${id}&token=${token}`;
        if (!!this._socket || !this._disconnected) return;
        this._socket = new WebSocket(wsUrl + "&version=" + $1572597be94ce13f$exports.version);
        this._disconnected = false;
        this._socket.onmessage = (event)=>{
            let data;
            try {
                data = JSON.parse(event.data);
                $81658c5d91b2b83a$export$2e2bcd8739ae039.log("Server message received:", data);
            } catch (e) {
                $81658c5d91b2b83a$export$2e2bcd8739ae039.log("Invalid server message", event.data);
                return;
            }
            this.emit($09f19ceb374f83a1$export$3b5c4a4b6354f023.Message, data);
        };
        this._socket.onclose = (event)=>{
            if (this._disconnected) return;
            $81658c5d91b2b83a$export$2e2bcd8739ae039.log("Socket closed.", event);
            this._cleanup();
            this._disconnected = true;
            this.emit($09f19ceb374f83a1$export$3b5c4a4b6354f023.Disconnected);
        };
        // Take care of the queue of connections if necessary and make sure Peer knows
        // socket is open.
        this._socket.onopen = ()=>{
            if (this._disconnected) return;
            this._sendQueuedMessages();
            $81658c5d91b2b83a$export$2e2bcd8739ae039.log("Socket open");
            this._scheduleHeartbeat();
        };
    }
    _scheduleHeartbeat() {
        this._wsPingTimer = setTimeout(()=>{
            this._sendHeartbeat();
        }, this.pingInterval);
    }
    _sendHeartbeat() {
        if (!this._wsOpen()) {
            $81658c5d91b2b83a$export$2e2bcd8739ae039.log(`Cannot send heartbeat, because socket closed`);
            return;
        }
        const message = JSON.stringify({
            type: $09f19ceb374f83a1$export$adb4a1754da6f10d.Heartbeat
        });
        this._socket.send(message);
        this._scheduleHeartbeat();
    }
    /** Is the websocket currently open? */ _wsOpen() {
        return !!this._socket && this._socket.readyState === 1;
    }
    /** Send queued messages. */ _sendQueuedMessages() {
        //Create copy of queue and clear it,
        //because send method push the message back to queue if smth will go wrong
        const copiedQueue = [
            ...this._messagesQueue
        ];
        this._messagesQueue = [];
        for (const message of copiedQueue)this.send(message);
    }
    /** Exposed send for DC & Peer. */ send(data) {
        if (this._disconnected) return;
        // If we didn't get an ID yet, we can't yet send anything so we should queue
        // up these messages.
        if (!this._id) {
            this._messagesQueue.push(data);
            return;
        }
        if (!data.type) {
            this.emit($09f19ceb374f83a1$export$3b5c4a4b6354f023.Error, "Invalid message");
            return;
        }
        if (!this._wsOpen()) return;
        const message = JSON.stringify(data);
        this._socket.send(message);
    }
    close() {
        if (this._disconnected) return;
        this._cleanup();
        this._disconnected = true;
    }
    _cleanup() {
        if (this._socket) {
            this._socket.onopen = this._socket.onmessage = this._socket.onclose = null;
            this._socket.close();
            this._socket = undefined;
        }
        clearTimeout(this._wsPingTimer);
    }
}







class $949f835b717af8ba$export$89e6bb5ad64bf4a {
    constructor(connection){
        this.connection = connection;
    }
    /** Returns a PeerConnection object set up correctly (for data, media). */ startConnection(options) {
        const peerConnection = this._startPeerConnection();
        // Set the connection's PC.
        this.connection.peerConnection = peerConnection;
        if (this.connection.type === $09f19ceb374f83a1$export$3157d57b4135e3bc.Media && options._stream) this._addTracksToConnection(options._stream, peerConnection);
        // What do we need to do now?
        if (options.originator) {
            if (this.connection.type === $09f19ceb374f83a1$export$3157d57b4135e3bc.Data) {
                const dataConnection = this.connection;
                const config = {
                    ordered: !!options.reliable
                };
                const dataChannel = peerConnection.createDataChannel(dataConnection.label, config);
                dataConnection.initialize(dataChannel);
            }
            this._makeOffer();
        } else this.handleSDP("OFFER", options.sdp);
    }
    /** Start a PC. */ _startPeerConnection() {
        $81658c5d91b2b83a$export$2e2bcd8739ae039.log("Creating RTCPeerConnection.");
        const peerConnection = new RTCPeerConnection(this.connection.provider.options.config);
        this._setupListeners(peerConnection);
        return peerConnection;
    }
    /** Set up various WebRTC listeners. */ _setupListeners(peerConnection) {
        const peerId = this.connection.peer;
        const connectionId = this.connection.connectionId;
        const connectionType = this.connection.type;
        const provider = this.connection.provider;
        // ICE CANDIDATES.
        $81658c5d91b2b83a$export$2e2bcd8739ae039.log("Listening for ICE candidates.");
        peerConnection.onicecandidate = (evt)=>{
            if (!evt.candidate || !evt.candidate.candidate) return;
            $81658c5d91b2b83a$export$2e2bcd8739ae039.log(`Received ICE candidates for ${peerId}:`, evt.candidate);
            provider.socket.send({
                type: $09f19ceb374f83a1$export$adb4a1754da6f10d.Candidate,
                payload: {
                    candidate: evt.candidate,
                    type: connectionType,
                    connectionId: connectionId
                },
                dst: peerId
            });
        };
        peerConnection.oniceconnectionstatechange = ()=>{
            switch(peerConnection.iceConnectionState){
                case "failed":
                    $81658c5d91b2b83a$export$2e2bcd8739ae039.log("iceConnectionState is failed, closing connections to " + peerId);
                    this.connection.emit($09f19ceb374f83a1$export$4aa6b1b0bfb253ab.Error, new Error("Negotiation of connection to " + peerId + " failed."));
                    this.connection.close();
                    break;
                case "closed":
                    $81658c5d91b2b83a$export$2e2bcd8739ae039.log("iceConnectionState is closed, closing connections to " + peerId);
                    this.connection.emit($09f19ceb374f83a1$export$4aa6b1b0bfb253ab.Error, new Error("Connection to " + peerId + " closed."));
                    this.connection.close();
                    break;
                case "disconnected":
                    $81658c5d91b2b83a$export$2e2bcd8739ae039.log("iceConnectionState changed to disconnected on the connection with " + peerId);
                    break;
                case "completed":
                    peerConnection.onicecandidate = $8677acc278daa2d1$export$7debb50ef11d5e0b.noop;
                    break;
            }
            this.connection.emit($09f19ceb374f83a1$export$4aa6b1b0bfb253ab.IceStateChanged, peerConnection.iceConnectionState);
        };
        // DATACONNECTION.
        $81658c5d91b2b83a$export$2e2bcd8739ae039.log("Listening for data channel");
        // Fired between offer and answer, so options should already be saved
        // in the options hash.
        peerConnection.ondatachannel = (evt)=>{
            $81658c5d91b2b83a$export$2e2bcd8739ae039.log("Received data channel");
            const dataChannel = evt.channel;
            const connection = provider.getConnection(peerId, connectionId);
            connection.initialize(dataChannel);
        };
        // MEDIACONNECTION.
        $81658c5d91b2b83a$export$2e2bcd8739ae039.log("Listening for remote stream");
        peerConnection.ontrack = (evt)=>{
            $81658c5d91b2b83a$export$2e2bcd8739ae039.log("Received remote stream");
            const stream = evt.streams[0];
            const connection = provider.getConnection(peerId, connectionId);
            if (connection.type === $09f19ceb374f83a1$export$3157d57b4135e3bc.Media) {
                const mediaConnection = connection;
                this._addStreamToMediaConnection(stream, mediaConnection);
            }
        };
    }
    cleanup() {
        $81658c5d91b2b83a$export$2e2bcd8739ae039.log("Cleaning up PeerConnection to " + this.connection.peer);
        const peerConnection = this.connection.peerConnection;
        if (!peerConnection) return;
        this.connection.peerConnection = null;
        //unsubscribe from all PeerConnection's events
        peerConnection.onicecandidate = peerConnection.oniceconnectionstatechange = peerConnection.ondatachannel = peerConnection.ontrack = ()=>{};
        const peerConnectionNotClosed = peerConnection.signalingState !== "closed";
        let dataChannelNotClosed = false;
        if (this.connection.type === $09f19ceb374f83a1$export$3157d57b4135e3bc.Data) {
            const dataConnection = this.connection;
            const dataChannel = dataConnection.dataChannel;
            if (dataChannel) dataChannelNotClosed = !!dataChannel.readyState && dataChannel.readyState !== "closed";
        }
        if (peerConnectionNotClosed || dataChannelNotClosed) peerConnection.close();
    }
    async _makeOffer() {
        const peerConnection = this.connection.peerConnection;
        const provider = this.connection.provider;
        try {
            const offer = await peerConnection.createOffer(this.connection.options.constraints);
            $81658c5d91b2b83a$export$2e2bcd8739ae039.log("Created offer.");
            if (this.connection.options.sdpTransform && typeof this.connection.options.sdpTransform === "function") offer.sdp = this.connection.options.sdpTransform(offer.sdp) || offer.sdp;
            try {
                await peerConnection.setLocalDescription(offer);
                $81658c5d91b2b83a$export$2e2bcd8739ae039.log("Set localDescription:", offer, `for:${this.connection.peer}`);
                let payload = {
                    sdp: offer,
                    type: this.connection.type,
                    connectionId: this.connection.connectionId,
                    metadata: this.connection.metadata,
                    browser: $8677acc278daa2d1$export$7debb50ef11d5e0b.browser
                };
                if (this.connection.type === $09f19ceb374f83a1$export$3157d57b4135e3bc.Data) {
                    const dataConnection = this.connection;
                    payload = {
                        ...payload,
                        label: dataConnection.label,
                        reliable: dataConnection.reliable,
                        serialization: dataConnection.serialization
                    };
                }
                provider.socket.send({
                    type: $09f19ceb374f83a1$export$adb4a1754da6f10d.Offer,
                    payload: payload,
                    dst: this.connection.peer
                });
            } catch (err) {
                // TODO: investigate why _makeOffer is being called from the answer
                if (err != "OperationError: Failed to set local offer sdp: Called in wrong state: kHaveRemoteOffer") {
                    provider.emitError($09f19ceb374f83a1$export$9547aaa2e39030ff.WebRTC, err);
                    $81658c5d91b2b83a$export$2e2bcd8739ae039.log("Failed to setLocalDescription, ", err);
                }
            }
        } catch (err_1) {
            provider.emitError($09f19ceb374f83a1$export$9547aaa2e39030ff.WebRTC, err_1);
            $81658c5d91b2b83a$export$2e2bcd8739ae039.log("Failed to createOffer, ", err_1);
        }
    }
    async _makeAnswer() {
        const peerConnection = this.connection.peerConnection;
        const provider = this.connection.provider;
        try {
            const answer = await peerConnection.createAnswer();
            $81658c5d91b2b83a$export$2e2bcd8739ae039.log("Created answer.");
            if (this.connection.options.sdpTransform && typeof this.connection.options.sdpTransform === "function") answer.sdp = this.connection.options.sdpTransform(answer.sdp) || answer.sdp;
            try {
                await peerConnection.setLocalDescription(answer);
                $81658c5d91b2b83a$export$2e2bcd8739ae039.log(`Set localDescription:`, answer, `for:${this.connection.peer}`);
                provider.socket.send({
                    type: $09f19ceb374f83a1$export$adb4a1754da6f10d.Answer,
                    payload: {
                        sdp: answer,
                        type: this.connection.type,
                        connectionId: this.connection.connectionId,
                        browser: $8677acc278daa2d1$export$7debb50ef11d5e0b.browser
                    },
                    dst: this.connection.peer
                });
            } catch (err) {
                provider.emitError($09f19ceb374f83a1$export$9547aaa2e39030ff.WebRTC, err);
                $81658c5d91b2b83a$export$2e2bcd8739ae039.log("Failed to setLocalDescription, ", err);
            }
        } catch (err_1) {
            provider.emitError($09f19ceb374f83a1$export$9547aaa2e39030ff.WebRTC, err_1);
            $81658c5d91b2b83a$export$2e2bcd8739ae039.log("Failed to create answer, ", err_1);
        }
    }
    /** Handle an SDP. */ async handleSDP(type, sdp) {
        sdp = new RTCSessionDescription(sdp);
        const peerConnection = this.connection.peerConnection;
        const provider = this.connection.provider;
        $81658c5d91b2b83a$export$2e2bcd8739ae039.log("Setting remote description", sdp);
        const self = this;
        try {
            await peerConnection.setRemoteDescription(sdp);
            $81658c5d91b2b83a$export$2e2bcd8739ae039.log(`Set remoteDescription:${type} for:${this.connection.peer}`);
            if (type === "OFFER") await self._makeAnswer();
        } catch (err) {
            provider.emitError($09f19ceb374f83a1$export$9547aaa2e39030ff.WebRTC, err);
            $81658c5d91b2b83a$export$2e2bcd8739ae039.log("Failed to setRemoteDescription, ", err);
        }
    }
    /** Handle a candidate. */ async handleCandidate(ice) {
        $81658c5d91b2b83a$export$2e2bcd8739ae039.log(`handleCandidate:`, ice);
        const candidate = ice.candidate;
        const sdpMLineIndex = ice.sdpMLineIndex;
        const sdpMid = ice.sdpMid;
        const peerConnection = this.connection.peerConnection;
        const provider = this.connection.provider;
        try {
            await peerConnection.addIceCandidate(new RTCIceCandidate({
                sdpMid: sdpMid,
                sdpMLineIndex: sdpMLineIndex,
                candidate: candidate
            }));
            $81658c5d91b2b83a$export$2e2bcd8739ae039.log(`Added ICE candidate for:${this.connection.peer}`);
        } catch (err) {
            provider.emitError($09f19ceb374f83a1$export$9547aaa2e39030ff.WebRTC, err);
            $81658c5d91b2b83a$export$2e2bcd8739ae039.log("Failed to handleCandidate, ", err);
        }
    }
    _addTracksToConnection(stream, peerConnection) {
        $81658c5d91b2b83a$export$2e2bcd8739ae039.log(`add tracks from stream ${stream.id} to peer connection`);
        if (!peerConnection.addTrack) return $81658c5d91b2b83a$export$2e2bcd8739ae039.error(`Your browser does't support RTCPeerConnection#addTrack. Ignored.`);
        stream.getTracks().forEach((track)=>{
            peerConnection.addTrack(track, stream);
        });
    }
    _addStreamToMediaConnection(stream, mediaConnection) {
        $81658c5d91b2b83a$export$2e2bcd8739ae039.log(`add stream ${stream.id} to media connection ${mediaConnection.connectionId}`);
        mediaConnection.addStream(stream);
    }
}




class $d3a7ed722f70cff3$export$23a2a68283c24d80 extends $duLG9$eventemitter3.EventEmitter {
    get open() {
        return this._open;
    }
    constructor(peer, provider, options){
        super();
        this.peer = peer;
        this.provider = provider;
        this.options = options;
        this._open = false;
        this.metadata = options.metadata;
    }
}


class $c850f63c298f91b6$export$4a84e95a2324ac29 extends $d3a7ed722f70cff3$export$23a2a68283c24d80 {
    static ID_PREFIX = "mc_";
    get type() {
        return $09f19ceb374f83a1$export$3157d57b4135e3bc.Media;
    }
    get localStream() {
        return this._localStream;
    }
    get remoteStream() {
        return this._remoteStream;
    }
    constructor(peerId, provider, options){
        super(peerId, provider, options);
        this._localStream = this.options._stream;
        this.connectionId = this.options.connectionId || $c850f63c298f91b6$export$4a84e95a2324ac29.ID_PREFIX + $8677acc278daa2d1$export$7debb50ef11d5e0b.randomToken();
        this._negotiator = new $949f835b717af8ba$export$89e6bb5ad64bf4a(this);
        if (this._localStream) this._negotiator.startConnection({
            _stream: this._localStream,
            originator: true
        });
    }
    addStream(remoteStream) {
        $81658c5d91b2b83a$export$2e2bcd8739ae039.log("Receiving stream", remoteStream);
        this._remoteStream = remoteStream;
        super.emit($09f19ceb374f83a1$export$4aa6b1b0bfb253ab.Stream, remoteStream); // Should we call this `open`?
    }
    handleMessage(message) {
        const type = message.type;
        const payload = message.payload;
        switch(message.type){
            case $09f19ceb374f83a1$export$adb4a1754da6f10d.Answer:
                // Forward to negotiator
                this._negotiator.handleSDP(type, payload.sdp);
                this._open = true;
                break;
            case $09f19ceb374f83a1$export$adb4a1754da6f10d.Candidate:
                this._negotiator.handleCandidate(payload.candidate);
                break;
            default:
                $81658c5d91b2b83a$export$2e2bcd8739ae039.warn(`Unrecognized message type:${type} from peer:${this.peer}`);
                break;
        }
    }
    answer(stream, options = {}) {
        if (this._localStream) {
            $81658c5d91b2b83a$export$2e2bcd8739ae039.warn("Local stream already exists on this MediaConnection. Are you answering a call twice?");
            return;
        }
        this._localStream = stream;
        if (options && options.sdpTransform) this.options.sdpTransform = options.sdpTransform;
        this._negotiator.startConnection({
            ...this.options._payload,
            _stream: stream
        });
        // Retrieve lost messages stored because PeerConnection not set up.
        const messages = this.provider._getMessages(this.connectionId);
        for (let message of messages)this.handleMessage(message);
        this._open = true;
    }
    /**
	 * Exposed functionality for users.
	 */ /** Allows user to close connection. */ close() {
        if (this._negotiator) {
            this._negotiator.cleanup();
            this._negotiator = null;
        }
        this._localStream = null;
        this._remoteStream = null;
        if (this.provider) {
            this.provider._removeConnection(this);
            this.provider = null;
        }
        if (this.options && this.options._stream) this.options._stream = null;
        if (!this.open) return;
        this._open = false;
        super.emit($09f19ceb374f83a1$export$4aa6b1b0bfb253ab.Close);
    }
}









class $aa285b148442aa0f$export$c6913ae0ed687038 extends $duLG9$eventemitter3.EventEmitter {
    fileReader = new FileReader();
    _queue = [];
    _processing = false;
    constructor(){
        super();
        this.fileReader.onload = (evt)=>{
            this._processing = false;
            if (evt.target) this.emit("done", evt.target.result);
            this.doNextTask();
        };
        this.fileReader.onerror = (evt)=>{
            $81658c5d91b2b83a$export$2e2bcd8739ae039.error(`EncodingQueue error:`, evt);
            this._processing = false;
            this.destroy();
            this.emit("error", evt);
        };
    }
    get queue() {
        return this._queue;
    }
    get size() {
        return this.queue.length;
    }
    get processing() {
        return this._processing;
    }
    enque(blob) {
        this.queue.push(blob);
        if (this.processing) return;
        this.doNextTask();
    }
    destroy() {
        this.fileReader.abort();
        this._queue = [];
    }
    doNextTask() {
        if (this.size === 0) return;
        if (this.processing) return;
        this._processing = true;
        this.fileReader.readAsArrayBuffer(this.queue.shift());
    }
}


class $3f896ebf95622e17$export$d365f7ad9d7df9c9 extends $d3a7ed722f70cff3$export$23a2a68283c24d80 {
    static ID_PREFIX = "dc_";
    static MAX_BUFFERED_AMOUNT = 8388608;
    stringify = JSON.stringify;
    parse = JSON.parse;
    get type() {
        return $09f19ceb374f83a1$export$3157d57b4135e3bc.Data;
    }
    _buffer = [];
    _bufferSize = 0;
    _buffering = false;
    _chunkedData = {};
    _encodingQueue = new $aa285b148442aa0f$export$c6913ae0ed687038();
    get dataChannel() {
        return this._dc;
    }
    get bufferSize() {
        return this._bufferSize;
    }
    constructor(peerId, provider, options){
        super(peerId, provider, options);
        this.connectionId = this.options.connectionId || $3f896ebf95622e17$export$d365f7ad9d7df9c9.ID_PREFIX + $8677acc278daa2d1$export$7debb50ef11d5e0b.randomToken();
        this.label = this.options.label || this.connectionId;
        this.serialization = this.options.serialization || $09f19ceb374f83a1$export$89f507cf986a947.Binary;
        this.reliable = !!this.options.reliable;
        this._encodingQueue.on("done", (ab)=>{
            this._bufferedSend(ab);
        });
        this._encodingQueue.on("error", ()=>{
            $81658c5d91b2b83a$export$2e2bcd8739ae039.error(`DC#${this.connectionId}: Error occured in encoding from blob to arraybuffer, close DC`);
            this.close();
        });
        this._negotiator = new $949f835b717af8ba$export$89e6bb5ad64bf4a(this);
        this._negotiator.startConnection(this.options._payload || {
            originator: true
        });
    }
    /** Called by the Negotiator when the DataChannel is ready. */ initialize(dc) {
        this._dc = dc;
        this._configureDataChannel();
    }
    _configureDataChannel() {
        if (!$8677acc278daa2d1$export$7debb50ef11d5e0b.supports.binaryBlob || $8677acc278daa2d1$export$7debb50ef11d5e0b.supports.reliable) this.dataChannel.binaryType = "arraybuffer";
        this.dataChannel.onopen = ()=>{
            $81658c5d91b2b83a$export$2e2bcd8739ae039.log(`DC#${this.connectionId} dc connection success`);
            this._open = true;
            this.emit($09f19ceb374f83a1$export$4aa6b1b0bfb253ab.Open);
        };
        this.dataChannel.onmessage = (e)=>{
            $81658c5d91b2b83a$export$2e2bcd8739ae039.log(`DC#${this.connectionId} dc onmessage:`, e.data);
            this._handleDataMessage(e);
        };
        this.dataChannel.onclose = ()=>{
            $81658c5d91b2b83a$export$2e2bcd8739ae039.log(`DC#${this.connectionId} dc closed for:`, this.peer);
            this.close();
        };
    }
    // Handles a DataChannel message.
    _handleDataMessage({ data: data  }) {
        const datatype = data.constructor;
        const isBinarySerialization = this.serialization === $09f19ceb374f83a1$export$89f507cf986a947.Binary || this.serialization === $09f19ceb374f83a1$export$89f507cf986a947.BinaryUTF8;
        let deserializedData = data;
        if (isBinarySerialization) {
            if (datatype === Blob) {
                // Datatype should never be blob
                $8677acc278daa2d1$export$7debb50ef11d5e0b.blobToArrayBuffer(data, (ab)=>{
                    const unpackedData = $8677acc278daa2d1$export$7debb50ef11d5e0b.unpack(ab);
                    this.emit($09f19ceb374f83a1$export$4aa6b1b0bfb253ab.Data, unpackedData);
                });
                return;
            } else if (datatype === ArrayBuffer) deserializedData = $8677acc278daa2d1$export$7debb50ef11d5e0b.unpack(data);
            else if (datatype === String) {
                // String fallback for binary data for browsers that don't support binary yet
                const ab = $8677acc278daa2d1$export$7debb50ef11d5e0b.binaryStringToArrayBuffer(data);
                deserializedData = $8677acc278daa2d1$export$7debb50ef11d5e0b.unpack(ab);
            }
        } else if (this.serialization === $09f19ceb374f83a1$export$89f507cf986a947.JSON) deserializedData = this.parse(data);
        // Check if we've chunked--if so, piece things back together.
        // We're guaranteed that this isn't 0.
        if (deserializedData.__peerData) {
            this._handleChunk(deserializedData);
            return;
        }
        super.emit($09f19ceb374f83a1$export$4aa6b1b0bfb253ab.Data, deserializedData);
    }
    _handleChunk(data) {
        const id = data.__peerData;
        const chunkInfo = this._chunkedData[id] || {
            data: [],
            count: 0,
            total: data.total
        };
        chunkInfo.data[data.n] = data.data;
        chunkInfo.count++;
        this._chunkedData[id] = chunkInfo;
        if (chunkInfo.total === chunkInfo.count) {
            // Clean up before making the recursive call to `_handleDataMessage`.
            delete this._chunkedData[id];
            // We've received all the chunks--time to construct the complete data.
            const data = new Blob(chunkInfo.data);
            this._handleDataMessage({
                data: data
            });
        }
    }
    /**
	 * Exposed functionality for users.
	 */ /** Allows user to close connection. */ close() {
        this._buffer = [];
        this._bufferSize = 0;
        this._chunkedData = {};
        if (this._negotiator) {
            this._negotiator.cleanup();
            this._negotiator = null;
        }
        if (this.provider) {
            this.provider._removeConnection(this);
            this.provider = null;
        }
        if (this.dataChannel) {
            this.dataChannel.onopen = null;
            this.dataChannel.onmessage = null;
            this.dataChannel.onclose = null;
            this._dc = null;
        }
        if (this._encodingQueue) {
            this._encodingQueue.destroy();
            this._encodingQueue.removeAllListeners();
            this._encodingQueue = null;
        }
        if (!this.open) return;
        this._open = false;
        super.emit($09f19ceb374f83a1$export$4aa6b1b0bfb253ab.Close);
    }
    /** Allows user to send data. */ send(data, chunked) {
        if (!this.open) {
            super.emit($09f19ceb374f83a1$export$4aa6b1b0bfb253ab.Error, new Error("Connection is not open. You should listen for the `open` event before sending messages."));
            return;
        }
        if (this.serialization === $09f19ceb374f83a1$export$89f507cf986a947.JSON) this._bufferedSend(this.stringify(data));
        else if (this.serialization === $09f19ceb374f83a1$export$89f507cf986a947.Binary || this.serialization === $09f19ceb374f83a1$export$89f507cf986a947.BinaryUTF8) {
            const blob = $8677acc278daa2d1$export$7debb50ef11d5e0b.pack(data);
            if (!chunked && blob.size > $8677acc278daa2d1$export$7debb50ef11d5e0b.chunkedMTU) {
                this._sendChunks(blob);
                return;
            }
            if (!$8677acc278daa2d1$export$7debb50ef11d5e0b.supports.binaryBlob) // We only do this if we really need to (e.g. blobs are not supported),
            // because this conversion is costly.
            this._encodingQueue.enque(blob);
            else this._bufferedSend(blob);
        } else this._bufferedSend(data);
    }
    _bufferedSend(msg) {
        if (this._buffering || !this._trySend(msg)) {
            this._buffer.push(msg);
            this._bufferSize = this._buffer.length;
        }
    }
    // Returns true if the send succeeds.
    _trySend(msg) {
        if (!this.open) return false;
        if (this.dataChannel.bufferedAmount > $3f896ebf95622e17$export$d365f7ad9d7df9c9.MAX_BUFFERED_AMOUNT) {
            this._buffering = true;
            setTimeout(()=>{
                this._buffering = false;
                this._tryBuffer();
            }, 50);
            return false;
        }
        try {
            this.dataChannel.send(msg);
        } catch (e) {
            $81658c5d91b2b83a$export$2e2bcd8739ae039.error(`DC#:${this.connectionId} Error when sending:`, e);
            this._buffering = true;
            this.close();
            return false;
        }
        return true;
    }
    // Try to send the first message in the buffer.
    _tryBuffer() {
        if (!this.open) return;
        if (this._buffer.length === 0) return;
        const msg = this._buffer[0];
        if (this._trySend(msg)) {
            this._buffer.shift();
            this._bufferSize = this._buffer.length;
            this._tryBuffer();
        }
    }
    _sendChunks(blob) {
        const blobs = $8677acc278daa2d1$export$7debb50ef11d5e0b.chunk(blob);
        $81658c5d91b2b83a$export$2e2bcd8739ae039.log(`DC#${this.connectionId} Try to send ${blobs.length} chunks...`);
        for (let blob1 of blobs)this.send(blob1, true);
    }
    handleMessage(message) {
        const payload = message.payload;
        switch(message.type){
            case $09f19ceb374f83a1$export$adb4a1754da6f10d.Answer:
                this._negotiator.handleSDP(message.type, payload.sdp);
                break;
            case $09f19ceb374f83a1$export$adb4a1754da6f10d.Candidate:
                this._negotiator.handleCandidate(payload.candidate);
                break;
            default:
                $81658c5d91b2b83a$export$2e2bcd8739ae039.warn("Unrecognized message type:", message.type, "from peer:", this.peer);
                break;
        }
    }
}






class $2187f9debc898cbf$export$2c4e825dc9120f87 {
    constructor(_options){
        this._options = _options;
    }
    _buildRequest(method) {
        const protocol = this._options.secure ? "https" : "http";
        const { host: host , port: port , path: path , key: key  } = this._options;
        const url = new URL(`${protocol}://${host}:${port}${path}${key}/${method}`);
        // TODO: Why timestamp, why random?
        url.searchParams.set("ts", `${Date.now()}${Math.random()}`);
        url.searchParams.set("version", $1572597be94ce13f$exports.version);
        return fetch(url.href, {
            referrerPolicy: "strict-origin-when-cross-origin"
        });
    }
    /** Get a unique ID from the server via XHR and initialize with it. */ async retrieveId() {
        try {
            const response = await this._buildRequest("id");
            if (response.status !== 200) throw new Error(`Error. Status:${response.status}`);
            return response.text();
        } catch (error) {
            $81658c5d91b2b83a$export$2e2bcd8739ae039.error("Error retrieving ID", error);
            let pathError = "";
            if (this._options.path === "/" && this._options.host !== $8677acc278daa2d1$export$7debb50ef11d5e0b.CLOUD_HOST) pathError = " If you passed in a `path` to your self-hosted PeerServer, you'll also need to pass in that same path when creating a new Peer.";
            throw new Error("Could not get an ID from the server." + pathError);
        }
    }
    /** @deprecated */ async listAllPeers() {
        try {
            const response = await this._buildRequest("peers");
            if (response.status !== 200) {
                if (response.status === 401) {
                    let helpfulError = "";
                    if (this._options.host === $8677acc278daa2d1$export$7debb50ef11d5e0b.CLOUD_HOST) helpfulError = "It looks like you're using the cloud server. You can email team@peerjs.com to enable peer listing for your API key.";
                    else helpfulError = "You need to enable `allow_discovery` on your self-hosted PeerServer to use this feature.";
                    throw new Error("It doesn't look like you have permission to list peers IDs. " + helpfulError);
                }
                throw new Error(`Error. Status:${response.status}`);
            }
            return response.json();
        } catch (error) {
            $81658c5d91b2b83a$export$2e2bcd8739ae039.error("Error retrieving list peers", error);
            throw new Error("Could not get list peers from the server." + error);
        }
    }
}


class $bdba2c07c560828e$var$PeerOptions {
}
class $bdba2c07c560828e$export$ecd1fc136c422448 extends $duLG9$eventemitter3.EventEmitter {
    static DEFAULT_KEY = "peerjs";
    _id = null;
    _lastServerId = null;
    // States.
    _destroyed = false;
    _disconnected = false;
    _open = false;
    _connections = new Map();
    _lostMessages = new Map();
    get id() {
        return this._id;
    }
    get options() {
        return this._options;
    }
    get open() {
        return this._open;
    }
    get socket() {
        return this._socket;
    }
    /**
	 * @deprecated
	 * Return type will change from Object to Map<string,[]>
	 */ get connections() {
        const plainConnections = Object.create(null);
        for (let [k, v] of this._connections)plainConnections[k] = v;
        return plainConnections;
    }
    get destroyed() {
        return this._destroyed;
    }
    get disconnected() {
        return this._disconnected;
    }
    constructor(id1, options){
        super();
        let userId;
        // Deal with overloading
        if (id1 && id1.constructor == Object) options = id1;
        else if (id1) userId = id1.toString();
        // Configurize options
        options = {
            debug: 0,
            host: $8677acc278daa2d1$export$7debb50ef11d5e0b.CLOUD_HOST,
            port: $8677acc278daa2d1$export$7debb50ef11d5e0b.CLOUD_PORT,
            path: "/",
            key: $bdba2c07c560828e$export$ecd1fc136c422448.DEFAULT_KEY,
            token: $8677acc278daa2d1$export$7debb50ef11d5e0b.randomToken(),
            config: $8677acc278daa2d1$export$7debb50ef11d5e0b.defaultConfig,
            ...options
        };
        this._options = options;
        // Detect relative URL host.
        if (this._options.host === "/") this._options.host = window.location.hostname;
        // Set path correctly.
        if (this._options.path) {
            if (this._options.path[0] !== "/") this._options.path = "/" + this._options.path;
            if (this._options.path[this._options.path.length - 1] !== "/") this._options.path += "/";
        }
        // Set whether we use SSL to same as current host
        if (this._options.secure === undefined && this._options.host !== $8677acc278daa2d1$export$7debb50ef11d5e0b.CLOUD_HOST) this._options.secure = $8677acc278daa2d1$export$7debb50ef11d5e0b.isSecure();
        else if (this._options.host == $8677acc278daa2d1$export$7debb50ef11d5e0b.CLOUD_HOST) this._options.secure = true;
        // Set a custom log function if present
        if (this._options.logFunction) $81658c5d91b2b83a$export$2e2bcd8739ae039.setLogFunction(this._options.logFunction);
        $81658c5d91b2b83a$export$2e2bcd8739ae039.logLevel = this._options.debug || 0;
        this._api = new $2187f9debc898cbf$export$2c4e825dc9120f87(options);
        this._socket = this._createServerConnection();
        // Sanity checks
        // Ensure WebRTC supported
        if (!$8677acc278daa2d1$export$7debb50ef11d5e0b.supports.audioVideo && !$8677acc278daa2d1$export$7debb50ef11d5e0b.supports.data) {
            this._delayedAbort($09f19ceb374f83a1$export$9547aaa2e39030ff.BrowserIncompatible, "The current browser does not support WebRTC");
            return;
        }
        // Ensure alphanumeric id
        if (!!userId && !$8677acc278daa2d1$export$7debb50ef11d5e0b.validateId(userId)) {
            this._delayedAbort($09f19ceb374f83a1$export$9547aaa2e39030ff.InvalidID, `ID "${userId}" is invalid`);
            return;
        }
        if (userId) this._initialize(userId);
        else this._api.retrieveId().then((id)=>this._initialize(id)
        ).catch((error)=>this._abort($09f19ceb374f83a1$export$9547aaa2e39030ff.ServerError, error)
        );
    }
    _createServerConnection() {
        const socket = new $9bb55f9334914a06$export$4798917dbf149b79(this._options.secure, this._options.host, this._options.port, this._options.path, this._options.key, this._options.pingInterval);
        socket.on($09f19ceb374f83a1$export$3b5c4a4b6354f023.Message, (data)=>{
            this._handleMessage(data);
        });
        socket.on($09f19ceb374f83a1$export$3b5c4a4b6354f023.Error, (error)=>{
            this._abort($09f19ceb374f83a1$export$9547aaa2e39030ff.SocketError, error);
        });
        socket.on($09f19ceb374f83a1$export$3b5c4a4b6354f023.Disconnected, ()=>{
            if (this.disconnected) return;
            this.emitError($09f19ceb374f83a1$export$9547aaa2e39030ff.Network, "Lost connection to server.");
            this.disconnect();
        });
        socket.on($09f19ceb374f83a1$export$3b5c4a4b6354f023.Close, ()=>{
            if (this.disconnected) return;
            this._abort($09f19ceb374f83a1$export$9547aaa2e39030ff.SocketClosed, "Underlying socket is already closed.");
        });
        return socket;
    }
    /** Initialize a connection with the server. */ _initialize(id) {
        this._id = id;
        this.socket.start(id, this._options.token);
    }
    /** Handles messages from the server. */ _handleMessage(message) {
        const type = message.type;
        const payload = message.payload;
        const peerId = message.src;
        switch(type){
            case $09f19ceb374f83a1$export$adb4a1754da6f10d.Open:
                this._lastServerId = this.id;
                this._open = true;
                this.emit($09f19ceb374f83a1$export$968b5e1359134530.Open, this.id);
                break;
            case $09f19ceb374f83a1$export$adb4a1754da6f10d.Error:
                this._abort($09f19ceb374f83a1$export$9547aaa2e39030ff.ServerError, payload.msg);
                break;
            case $09f19ceb374f83a1$export$adb4a1754da6f10d.IdTaken:
                this._abort($09f19ceb374f83a1$export$9547aaa2e39030ff.UnavailableID, `ID "${this.id}" is taken`);
                break;
            case $09f19ceb374f83a1$export$adb4a1754da6f10d.InvalidKey:
                this._abort($09f19ceb374f83a1$export$9547aaa2e39030ff.InvalidKey, `API KEY "${this._options.key}" is invalid`);
                break;
            case $09f19ceb374f83a1$export$adb4a1754da6f10d.Leave:
                $81658c5d91b2b83a$export$2e2bcd8739ae039.log(`Received leave message from ${peerId}`);
                this._cleanupPeer(peerId);
                this._connections.delete(peerId);
                break;
            case $09f19ceb374f83a1$export$adb4a1754da6f10d.Expire:
                this.emitError($09f19ceb374f83a1$export$9547aaa2e39030ff.PeerUnavailable, `Could not connect to peer ${peerId}`);
                break;
            case $09f19ceb374f83a1$export$adb4a1754da6f10d.Offer:
                {
                    // we should consider switching this to CALL/CONNECT, but this is the least breaking option.
                    const connectionId = payload.connectionId;
                    let connection = this.getConnection(peerId, connectionId);
                    if (connection) {
                        connection.close();
                        $81658c5d91b2b83a$export$2e2bcd8739ae039.warn(`Offer received for existing Connection ID:${connectionId}`);
                    }
                    // Create a new connection.
                    if (payload.type === $09f19ceb374f83a1$export$3157d57b4135e3bc.Media) {
                        connection = new $c850f63c298f91b6$export$4a84e95a2324ac29(peerId, this, {
                            connectionId: connectionId,
                            _payload: payload,
                            metadata: payload.metadata
                        });
                        this._addConnection(peerId, connection);
                        this.emit($09f19ceb374f83a1$export$968b5e1359134530.Call, connection);
                    } else if (payload.type === $09f19ceb374f83a1$export$3157d57b4135e3bc.Data) {
                        connection = new $3f896ebf95622e17$export$d365f7ad9d7df9c9(peerId, this, {
                            connectionId: connectionId,
                            _payload: payload,
                            metadata: payload.metadata,
                            label: payload.label,
                            serialization: payload.serialization,
                            reliable: payload.reliable
                        });
                        this._addConnection(peerId, connection);
                        this.emit($09f19ceb374f83a1$export$968b5e1359134530.Connection, connection);
                    } else {
                        $81658c5d91b2b83a$export$2e2bcd8739ae039.warn(`Received malformed connection type:${payload.type}`);
                        return;
                    }
                    // Find messages.
                    const messages = this._getMessages(connectionId);
                    for (let message of messages)connection.handleMessage(message);
                    break;
                }
            default:
                {
                    if (!payload) {
                        $81658c5d91b2b83a$export$2e2bcd8739ae039.warn(`You received a malformed message from ${peerId} of type ${type}`);
                        return;
                    }
                    const connectionId = payload.connectionId;
                    const connection = this.getConnection(peerId, connectionId);
                    if (connection && connection.peerConnection) // Pass it on.
                    connection.handleMessage(message);
                    else if (connectionId) // Store for possible later use
                    this._storeMessage(connectionId, message);
                    else $81658c5d91b2b83a$export$2e2bcd8739ae039.warn("You received an unrecognized message:", message);
                    break;
                }
        }
    }
    /** Stores messages without a set up connection, to be claimed later. */ _storeMessage(connectionId, message) {
        if (!this._lostMessages.has(connectionId)) this._lostMessages.set(connectionId, []);
        this._lostMessages.get(connectionId).push(message);
    }
    /** Retrieve messages from lost message store */ //TODO Change it to private
    _getMessages(connectionId) {
        const messages = this._lostMessages.get(connectionId);
        if (messages) {
            this._lostMessages.delete(connectionId);
            return messages;
        }
        return [];
    }
    /**
	 * Returns a DataConnection to the specified peer. See documentation for a
	 * complete list of options.
	 */ connect(peer, options = {}) {
        if (this.disconnected) {
            $81658c5d91b2b83a$export$2e2bcd8739ae039.warn("You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect, or call reconnect on this peer if you believe its ID to still be available.");
            this.emitError($09f19ceb374f83a1$export$9547aaa2e39030ff.Disconnected, "Cannot connect to new Peer after disconnecting from server.");
            return;
        }
        const dataConnection = new $3f896ebf95622e17$export$d365f7ad9d7df9c9(peer, this, options);
        this._addConnection(peer, dataConnection);
        return dataConnection;
    }
    /**
	 * Returns a MediaConnection to the specified peer. See documentation for a
	 * complete list of options.
	 */ call(peer, stream, options = {}) {
        if (this.disconnected) {
            $81658c5d91b2b83a$export$2e2bcd8739ae039.warn("You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect.");
            this.emitError($09f19ceb374f83a1$export$9547aaa2e39030ff.Disconnected, "Cannot connect to new Peer after disconnecting from server.");
            return;
        }
        if (!stream) {
            $81658c5d91b2b83a$export$2e2bcd8739ae039.error("To call a peer, you must provide a stream from your browser's `getUserMedia`.");
            return;
        }
        options._stream = stream;
        const mediaConnection = new $c850f63c298f91b6$export$4a84e95a2324ac29(peer, this, options);
        this._addConnection(peer, mediaConnection);
        return mediaConnection;
    }
    /** Add a data/media connection to this peer. */ _addConnection(peerId, connection) {
        $81658c5d91b2b83a$export$2e2bcd8739ae039.log(`add connection ${connection.type}:${connection.connectionId} to peerId:${peerId}`);
        if (!this._connections.has(peerId)) this._connections.set(peerId, []);
        this._connections.get(peerId).push(connection);
    }
    //TODO should be private
    _removeConnection(connection) {
        const connections = this._connections.get(connection.peer);
        if (connections) {
            const index = connections.indexOf(connection);
            if (index !== -1) connections.splice(index, 1);
        }
        //remove from lost messages
        this._lostMessages.delete(connection.connectionId);
    }
    /** Retrieve a data/media connection for this peer. */ getConnection(peerId, connectionId) {
        const connections = this._connections.get(peerId);
        if (!connections) return null;
        for (let connection of connections){
            if (connection.connectionId === connectionId) return connection;
        }
        return null;
    }
    _delayedAbort(type, message) {
        setTimeout(()=>{
            this._abort(type, message);
        }, 0);
    }
    /**
	 * Emits an error message and destroys the Peer.
	 * The Peer is not destroyed if it's in a disconnected state, in which case
	 * it retains its disconnected state and its existing connections.
	 */ _abort(type, message) {
        $81658c5d91b2b83a$export$2e2bcd8739ae039.error("Aborting!");
        this.emitError(type, message);
        if (!this._lastServerId) this.destroy();
        else this.disconnect();
    }
    /** Emits a typed error message. */ emitError(type, err) {
        $81658c5d91b2b83a$export$2e2bcd8739ae039.error("Error:", err);
        let error;
        if (typeof err === "string") error = new Error(err);
        else error = err;
        error.type = type;
        this.emit($09f19ceb374f83a1$export$968b5e1359134530.Error, error);
    }
    /**
	 * Destroys the Peer: closes all active connections as well as the connection
	 *  to the server.
	 * Warning: The peer can no longer create or accept connections after being
	 *  destroyed.
	 */ destroy() {
        if (this.destroyed) return;
        $81658c5d91b2b83a$export$2e2bcd8739ae039.log(`Destroy peer with ID:${this.id}`);
        this.disconnect();
        this._cleanup();
        this._destroyed = true;
        this.emit($09f19ceb374f83a1$export$968b5e1359134530.Close);
    }
    /** Disconnects every connection on this peer. */ _cleanup() {
        for (let peerId of this._connections.keys()){
            this._cleanupPeer(peerId);
            this._connections.delete(peerId);
        }
        this.socket.removeAllListeners();
    }
    /** Closes all connections to this peer. */ _cleanupPeer(peerId) {
        const connections = this._connections.get(peerId);
        if (!connections) return;
        for (let connection of connections)connection.close();
    }
    /**
	 * Disconnects the Peer's connection to the PeerServer. Does not close any
	 *  active connections.
	 * Warning: The peer can no longer create or accept connections after being
	 *  disconnected. It also cannot reconnect to the server.
	 */ disconnect() {
        if (this.disconnected) return;
        const currentId = this.id;
        $81658c5d91b2b83a$export$2e2bcd8739ae039.log(`Disconnect peer with ID:${currentId}`);
        this._disconnected = true;
        this._open = false;
        this.socket.close();
        this._lastServerId = currentId;
        this._id = null;
        this.emit($09f19ceb374f83a1$export$968b5e1359134530.Disconnected, currentId);
    }
    /** Attempts to reconnect with the same ID. */ reconnect() {
        if (this.disconnected && !this.destroyed) {
            $81658c5d91b2b83a$export$2e2bcd8739ae039.log(`Attempting reconnection to server with ID ${this._lastServerId}`);
            this._disconnected = false;
            this._initialize(this._lastServerId);
        } else if (this.destroyed) throw new Error("This peer cannot reconnect to the server. It has already been destroyed.");
        else if (!this.disconnected && !this.open) // Do nothing. We're still connecting the first time.
        $81658c5d91b2b83a$export$2e2bcd8739ae039.error("In a hurry? We're still trying to make the initial connection!");
        else throw new Error(`Peer ${this.id} cannot reconnect because it is not disconnected from the server!`);
    }
    /**
	 * Get a list of available peer IDs. If you're running your own server, you'll
	 * want to set allow_discovery: true in the PeerServer options. If you're using
	 * the cloud server, email team@peerjs.com to get the functionality enabled for
	 * your key.
	 */ listAllPeers(cb = (_)=>{}) {
        this._api.listAllPeers().then((peers)=>cb(peers)
        ).catch((error)=>this._abort($09f19ceb374f83a1$export$9547aaa2e39030ff.ServerError, error)
        );
    }
}


var $8dc2c2301642b6f0$export$2e2bcd8739ae039 = $bdba2c07c560828e$export$ecd1fc136c422448;


//# sourceMappingURL=bundler.cjs.map
